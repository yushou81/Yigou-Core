# 箭头运行逻辑详细说明

## 概述

箭头的运行逻辑是一个**数据流验证与传递系统**，类似于 Spring Boot 的参数绑定机制。当用户点击"运行"按钮时，系统会从起点（Start）开始，沿着箭头（Arrow）遍历所有节点（Node），验证数据匹配，并传递数据。

## 核心流程

### 1. 初始化阶段（Canvas.tsx 第 1177-1182 行）

```typescript
// 1. 先清除所有箭头状态
const arrows = shapes.filter(s => s.type === 'arrow');
arrows.forEach(arrow => {
  updateShape(arrow.id, { validationStatus: null });
});
```

**作用：** 清除所有箭头的验证状态，为新一轮运行做准备。

### 2. 数据结构准备（Canvas.tsx 第 1184-1190 行）

```typescript
// 2. 运行：从起点沿箭头验证输入输出并传递数据
const shapesNow = [...shapes];
const nodesById = new Map(shapesNow.filter(s => s.type === 'node' || s.type === 'start').map(s => [s.id, s]));
const arrowsNow = shapesNow.filter(s => s.type === 'arrow');
const outgoing = new Map<string, any[]>(
  [...nodesById.keys()].map(id => [id, arrowsNow.filter(a => (a as any).sourceNodeId === id || (a as any).startNodeId === id)])
);
```

**作用：**
- `nodesById`: 创建节点 ID 到节点对象的映射，用于快速查找
- `outgoing`: 创建每个节点的出边映射，记录从该节点出发的所有箭头

### 3. 从起点开始遍历（Canvas.tsx 第 1452-1513 行）

```typescript
// 从起点开始遍历（顺序执行，等待每个箭头动画完成）
const starts = shapesNow.filter(s => s.type === 'start');
for (const start of starts) {
  const queue: Array<{ nodeId: string; sourceNode?: any }> = [{ nodeId: start.id }];
  const visited = new Set<string>();
  
  while (queue.length) {
    const { nodeId: currentId } = queue.shift()!;
    if (visited.has(currentId)) continue; // 避免循环
    visited.add(currentId);
    const currentNode = nodesById.get(currentId);
    if (!currentNode) continue;

    // ... 处理当前节点的输出和箭头
  }
}
```

**算法：** 使用**广度优先搜索（BFS）**从起点开始遍历所有节点。

**关键点：**
- `queue`: 待处理的节点队列
- `visited`: 已访问节点集合，防止循环引用

### 4. 处理当前节点的输出（Canvas.tsx 第 1465-1469 行）

```typescript
// 运行API获取输出（如果需要）
await runApiIfNeeded(currentNode);

// 获取源节点的输出数据
const sourceOutputData = getOutputData(currentNode);
```

#### 4.1 运行 API（如果需要）（Canvas.tsx 第 1354-1387 行）

```typescript
const runApiIfNeeded = async (node: any) => {
  const mode = node.outputMode || (node.outputDataEnabled ? 'custom' : (node.apiUseAsOutput ? 'api' : 'props'));
  if (mode !== 'api') return;
  if (!node.apiEnabled || !node.apiUrl) return;
  
  // 发送 HTTP 请求
  const res = await fetch(node.apiUrl, init);
  // 解析结果并更新节点的 outputData
  updateShape(node.id, { outputData: newOutput, lastRunAt: Date.now() });
};
```

**作用：** 如果节点配置了 API 调用，在此阶段执行并获取结果。

#### 4.2 获取输出数据（Canvas.tsx 第 1216-1246 行）

```typescript
const getOutputData = (node: any): Record<string, any> => {
  const mode = node.outputMode || (node.outputDataEnabled ? 'custom' : (node.apiUseAsOutput ? 'api' : 'props'));
  
  if (mode === 'props') {
    // Props 模式：从 outputProps 和 outputData 构建数据对象
    const props = (node.outputProps || []).filter((k: string) => !!k);
    const data: Record<string, any> = {};
    props.forEach((prop: string) => {
      if (node.outputData && node.outputData[prop] !== undefined) {
        data[prop] = node.outputData[prop];
      }
    });
    return data;
  }
  
  if (mode === 'api') {
    // API 模式：解析 API 返回结果
    const apiResult = node.outputData?.apiResult;
    if (apiResult) {
      return parseApiResult(apiResult);
    }
    return {};
  }
  
  // Custom 模式：直接使用 outputData
  return node.outputData && typeof node.outputData === 'object' && !Array.isArray(node.outputData) ? node.outputData : {};
};
```

**三种输出模式：**
1. **Props 模式**：从 `outputProps` 定义的属性列表构建数据对象
2. **API 模式**：从 API 调用结果中解析数据
3. **Custom 模式**：直接使用 `outputData` 中的自定义数据

### 5. 处理从当前节点出发的箭头（Canvas.tsx 第 1471-1512 行）

```typescript
// 处理所有从当前节点出发的箭头（按顺序，等待每个动画完成）
const outs = outgoing.get(currentId) || [];
// 根据箭头的 order 字段进行排序：数值越小越先运行
const sortedOuts = [...outs].sort((a: any, b: any) => {
  const ao = typeof a.order === 'number' ? a.order : Number.POSITIVE_INFINITY;
  const bo = typeof b.order === 'number' ? b.order : Number.POSITIVE_INFINITY;
  if (ao === bo) return 0;
  return ao - bo;
});

for (const arr of sortedOuts) {
  const arrowId = arr.id;
  const targetId = (arr as any).targetNodeId || (arr as any).endNodeId;
  
  // 验证数据匹配
  const validation = validateDataMatch(sourceOutputData, targetNode, currentNode);
  
  if (validation.match) {
    // 验证成功：箭头变绿，传递数据
    await waitForArrowAnimation(arrowId, 'success');
    passDataToTarget(sourceOutputData, targetNode);
    queue.push({ nodeId: targetId }); // 将目标节点加入队列
  } else {
    // 验证失败：箭头变红
    await waitForArrowAnimation(arrowId, 'error');
  }
}
```

**关键点：**
- **按 `order` 排序**：数值越小的箭头越先运行
- **顺序执行**：使用 `await` 等待每个箭头动画完成后再处理下一个
- **验证数据匹配**：检查源节点的输出是否满足目标节点的输入要求

### 6. 数据验证（Canvas.tsx 第 1285-1337 行）

```typescript
const validateDataMatch = (sourceData: Record<string, any>, targetNode: any, sourceNode: any): { match: boolean; missing: string[]; message: string } => {
  const mode = targetNode.inputMode || (targetNode.inputDataEnabled ? 'custom' : 'props');
  
  if (mode === 'props') {
    // Props 模式：类似 @RequestParam，基于属性名的精确匹配
    const requiredProps = (targetNode.inputProps || []).filter((k: string) => !!k);
    
    // 获取源节点的输出属性列表
    const sourceOutputProps = /* ... 从源节点获取输出属性名列表 ... */;
    
    const sourcePropsSet = new Set(sourceOutputProps);
    const missing = requiredProps.filter(prop => !sourcePropsSet.has(prop));
    
    if (missing.length === 0) {
      return { match: true, missing: [], message: '参数匹配成功' };
    }
    return { match: false, missing, message: `缺少必需参数: ${missing.join(', ')}` };
  }
  
  // Custom 模式：类似 @RequestBody，递归检查对象结构
  const expectedStructure = targetNode.inputData;
  if (expectedStructure && typeof expectedStructure === 'object' && !Array.isArray(expectedStructure)) {
    const result = checkStructureMatch(sourceData, expectedStructure);
    return {
      match: result.match,
      missing: result.missing,
      message: result.match ? '数据结构匹配成功' : `缺少必需字段: ${result.missing.join(', ')}`
    };
  }
  
  return { match: true, missing: [], message: '允许任意输入' };
};
```

**两种验证模式：**
1. **Props 模式**（类似 Spring Boot 的 `@RequestParam`）：
   - 检查源节点的输出属性名是否包含目标节点所需的所有属性名
   - 只验证属性名存在，不验证值是否存在

2. **Custom 模式**（类似 Spring Boot 的 `@RequestBody`）：
   - 递归检查源数据对象的结构是否匹配目标节点期望的结构
   - 支持嵌套对象的验证

### 7. 数据传递（Canvas.tsx 第 1389-1439 行）

```typescript
const passDataToTarget = (sourceData: Record<string, any>, targetNode: any) => {
  const mode = targetNode.inputMode || (targetNode.inputDataEnabled ? 'custom' : 'props');
  
  if (mode === 'props') {
    // Props 模式：按属性名精确绑定
    const inputProps = (targetNode.inputProps || []).filter((k: string) => !!k);
    const newInputData: Record<string, any> = {};
    inputProps.forEach((prop: string) => {
      if (sourceData[prop] !== undefined) {
        newInputData[prop] = sourceData[prop];
      }
    });
    updateShape(targetNode.id, { inputData: newInputData });
  } else {
    // Custom 模式：传递完整对象（或匹配的部分）
    // 如果目标定义了期望结构，只传递匹配的部分；否则传递全部
    updateShape(targetNode.id, { inputData: matchedData });
  }
};
```

**两种传递模式：**
1. **Props 模式**：只传递目标节点所需属性名的值
2. **Custom 模式**：传递完整对象（如果目标定义了期望结构，只传递匹配的部分）

### 8. 箭头动画显示（Arrow.tsx 第 50-93 行）

```typescript
// 当验证状态变为 success 或 error 时，触发渐变动画
useEffect(() => {
  const prevStatus = prevStatusRef.current;
  const currentStatus = data.validationStatus;
  
  // 如果从其他状态变为 success 或 error，启动动画
  if ((prevStatus !== 'success' && currentStatus === 'success') ||
      (prevStatus !== 'error' && currentStatus === 'error')) {
    setAnimationProgress(0);
    const startTime = Date.now();
    const duration = 300; // 动画时长 300ms
    
    const animate = () => {
      const elapsed = Date.now() - startTime;
      const progress = Math.min(elapsed / duration, 1);
      setAnimationProgress(progress);
      
      if (progress < 1) {
        animationRef.current = requestAnimationFrame(animate);
      }
    };
    
    animationRef.current = requestAnimationFrame(animate);
  }
}, [data.validationStatus]);
```

**动画逻辑：**
- 当箭头状态变为 `success` 或 `error` 时，启动 300ms 的渐变动画
- 使用 `requestAnimationFrame` 实现平滑动画
- 动画进度从 0 到 1，控制箭头颜色的渐变显示

### 9. 箭头颜色显示（Arrow.tsx 第 95-102 行）

```typescript
const strokeColor = useMemo(() => {
  if (data.validationStatus === 'success') return '#22c55e'; // 绿色-成功
  if (data.validationStatus === 'error') return '#ef4444'; // 红色-失败
  if (data.validationStatus === 'pending') return '#f59e0b'; // 橙色-验证中
  // 默认颜色
  return isSelected ? '#111' : '#555';
}, [data.validationStatus, isSelected]);
```

**颜色规则：**
- `success`: 绿色 (#22c55e)
- `error`: 红色 (#ef4444)
- `pending`: 橙色 (#f59e0b) - 验证中
- 默认：选中时黑色，未选中时灰色

### 10. 等待动画完成（Canvas.tsx 第 1441-1450 行）

```typescript
const waitForArrowAnimation = (arrowId: string, status: 'success' | 'error'): Promise<void> => {
  return new Promise((resolve) => {
    updateShape(arrowId, { validationStatus: status });
    // 等待动画完成（300ms）
    setTimeout(() => {
      resolve();
    }, 300);
  });
};
```

**作用：** 确保每个箭头的动画完成后再继续处理下一个箭头，提供清晰的视觉反馈。

## 完整流程图

```
用户点击"运行"按钮
    ↓
清除所有箭头状态
    ↓
准备数据结构（节点映射、出边映射）
    ↓
从起点（Start）开始 BFS 遍历
    ↓
对每个节点：
  1. 运行 API（如果需要）
  2. 获取输出数据
  3. 处理所有出边箭头：
     a. 按 order 排序
     b. 标记为 pending（橙色）
     c. 验证数据匹配
     d. 如果匹配：
        - 标记为 success（绿色）
        - 传递数据到目标节点
        - 将目标节点加入队列
     e. 如果不匹配：
        - 标记为 error（红色）
     f. 等待动画完成（300ms）
    ↓
继续处理队列中的下一个节点
    ↓
直到队列为空，运行完成
```

## 设计模式类比

这个系统类似于 **Spring Boot 的参数绑定机制**：

1. **Props 模式** = `@RequestParam`：按属性名精确匹配
2. **Custom 模式** = `@RequestBody`：按对象结构递归验证
3. **API 模式** = `@ResponseBody`：解析 API 返回结果

## 关键特性

1. **顺序执行**：按箭头的 `order` 字段排序执行
2. **异步等待**：每个箭头动画完成后再处理下一个
3. **数据验证**：支持两种验证模式（Props 和 Custom）
4. **视觉反馈**：通过颜色和动画显示验证状态
5. **循环检测**：使用 `visited` 集合防止循环引用

