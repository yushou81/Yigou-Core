# “易构”项目 - 编码规范文档

**版本**: 1.0
**日期**: 2025-09-27

## 1. 核心原则 (Core Principles)

本规范旨在提高代码质量、一致性和可维护性。我们遵循以下几个核心原则：

- **自动化优先 (Automation First)**：代码风格问题应尽可能通过工具自动解决，而不是通过人力审查。
- **清晰胜于巧妙 (Clarity > Cleverness)**：代码首先是写给人看的，其次才是给机器执行的。
- **保持一致 (Consistency is Key)**：在遵循本文档的基础上，参考项目现有代码的风格。

---

## 2. 代码格式化 (Code Formatting)

- **唯一真理**: **Prettier**。
- **规范**: 我们在项目中集成了 Prettier。所有提交到代码库的 `js`, `ts`, `jsx`, `tsx`, `json`, `md` 文件都必须经过 Prettier 格式化。
- **执行**: 强烈建议在你的代码编辑器中安装 Prettier 插件，并开启“保存时自动格式化”。在提交代码前，可以手动运行 `pnpm format` 来格式化所有文件。

---

## 3. 命名规范 (Naming Conventions)

清晰的命名是代码可读性的基石。

| 类型                     | 规范                          | 示例 (Good)                                         | 示例 (Bad)                          |
| :----------------------- | :---------------------------- | :-------------------------------------------------- | :---------------------------------- |
| **文件 (Components)**    | 大驼峰 (PascalCase)           | `Canvas.tsx`, `ComponentPanel.tsx`                  | `canvas.tsx`, `component-panel.tsx` |
| **文件 (非 Components)** | 短横线 (kebab-case)           | `file-service.ts`, `api-client.ts`                  | `fileService.ts`, `ApiClient.ts`    |
| **变量 & 函数**          | 小驼峰 (camelCase)            | `const userCount = 10;`, `function getDiagram() {}` | `const UserCount = 10;`             |
| **常量**                 | 大写下划线 (UPPER_SNAKE_CASE) | `const MAX_ZOOM_LEVEL = 3;`                         | `const maxZoomLevel = 3;`           |
| **类, 接口, 类型, 枚举** | 大驼峰 (PascalCase)           | `class Diagram { ... }`, `interface INode { ... }`  | `class diagram { ... }`             |

---

## 4. TypeScript 规范

- **杜绝 `any`**: 除非有极其充分的理由并加以注释，否则**严禁使用 `any`**。尽可能使用 `unknown` 或更具体的类型。
- **类型定义**:
    
    - **优先使用 `interface`**: 定义对象或类的结构时，优先使用 `interface`。
        ```typescript
        // Good
        interface Node {
          id: string;
          position: { x: number; y: number };
        }
        ```
    - **使用 `type`**: 定义联合类型、交叉类型或基本类型的别名时，使用 `type`。
        ```typescript
        // Good
        type ComponentType = 'Person' | 'System' | 'Container';
        type NodeId = string;
        ```
- **函数类型**: 完整标注函数参数和返回值的类型。

---

## 5. React 规范

- **函数式组件**: 所有新组件**必须**使用函数式组件 (Functional Components) 和 Hooks 编写，**禁止**使用类组件 (Class Components)。
- **组件结构**:
    
    - 一个文件只包含一个核心组件。
    - 组件Props必须使用 TypeScript `interface` 或 `type` 进行定义。
    - 在函数参数中解构 Props，并提供默认值。
    - **示例**:
      ```tsx
      import React, { useState } from 'react';
      
      interface ButtonProps {
        label: string;
        onClick: () => void;
        disabled?: boolean;
      }
      
      const CustomButton = ({ label, onClick, disabled = false }: ButtonProps) => {
        // ... component logic
        return (
          <button onClick={onClick} disabled={disabled}>
            {label}
          </button>
        );
      };
      
      export default CustomButton;
      ```
- **状态管理**: 简单状态使用 `useState`。跨组件的复杂状态，遵循[技术设计文档](yigou_tech_design_mvp.md)中的规定，使用 **Zustand** 进行管理。

---

## 6. 项目结构与架构

- **严格遵守**: 必须遵循[技术设计文档](yigou_tech_design_mvp.md)中定义的 **主进程/渲染进程/共享代码** 的目录结构。
- **关注点分离**:
    - UI 逻辑保留在 React 组件中。
    - 跨组件的、复杂的应用状态逻辑，抽离到 Zustand Store 中。
    - 与操作系统交互的、Node.js 相关的核心逻辑，**必须**放在 `src/main` 目录下的服务中，通过 IPC 与渲染进程通信。

---

## 7. Git 工作流

- **分支模型**:
    - `main`: 主分支，永远保持稳定和可发布。
    - `feature/<feature-name>`: 开发新功能的分支，从 `main` 切出。
    - `fix/<issue-number>`: 修复 Bug 的分支，从 `main` 切出。
- **Commit Messages**: 严格遵循我们在 `CONTRIBUTING.md` 中定义的 **[Conventional Commits](https://www.conventionalcommits.org/)** 规范。
    - **示例**: `feat: implement png export functionality`
- **Pull Requests (PR)**:
    - 所有向 `main` 分支的合并都必须通过 Pull Request 进行。
    - PR 必须至少有一位其他团队成员的审查 (Code Review) 和批准。

---

## 8. 注释与文档

- **原则**: 注释应该解释**“为什么 (Why)”**，而不是“是什么 (What)”。代码本身应该能解释“是什么”。
- **推荐**: 对于公共的函数、接口和复杂的逻辑，使用 **JSDoc** 风格的注释，以便编辑器能提供更好的智能提示。
  ```typescript
  /**
   * Calculates the distance between two nodes.
   * @param nodeA - The first node.
   * @param nodeB - The second node.
   * @returns The Euclidean distance.
   */
  function calculateDistance(nodeA: Node, nodeB: Node): number {
    // ... complex logic
  }